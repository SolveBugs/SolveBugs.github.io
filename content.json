[{"title":"StickyListHeadersListView遇到的一个问题","date":"2017-05-26T02:54:18.000Z","path":"2017/05/26/StickyListHeadersListView遇到的一个问题/","text":"最近一直忙着版本更新，记录一下中间遇到的一些问题。 ExpandableStickyListHeadersListView这个开源库主要是实现列表分组的，常见的需求用它还是不错的，项目中也有用到这个控件，一直没有什么问题，但是，这期需求测试在用华为nexus p6做测试的时候，发现了一个奇怪的问题： 在列表快速滑动的时候，点击返回键离开当前界面，app会崩溃，崩溃日志如下：1Attempt to invoke virtual method 'void android.view.View.dispatchWindowFocusChanged() on a null object (大致意思是用一个空的对象调用了dispatchWindowFocusChanged（）方法) 起初以为是app逻辑问题，这样的话应该是必现的，但是试了华为，oppo，魅族以及小米后，都没有出现这个问题。于是goole，但是也没有搜到，怀疑是系统某个地方出现异常了…虽然没有搜到解决办法，但是也得解啊（不然没法儿上线…） 中间也试了不少办法，但是都没用，最后想到，既然是View对象调用方法的时候出现异常导致程序崩溃，那我是不是可以复写这个方法，捕捉异常来保证不崩溃？于是重写方法： 12345678@Override public void dispatchWindowFocusChanged(boolean hasFocus) &#123; try &#123; super.dispatchWindowFocusChanged(hasFocus); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 再在华为nexux p6上测试，问题解决。","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"webview调用android代码","date":"2017-05-05T10:13:52.000Z","path":"2017/05/05/webview调用android代码/","text":"在开发的时候经常会用到webview，必然会涉及到webview与客户端的交互，比如在网页上进行某个操作后，需要在app上显示一个提示，提示内容由网页提供，这时候就需要js来调用客户端的java代码了。 webview提供了一个方法addJavascriptInterface()来满足这种需求。 具体步骤： 客户端定义一个类，并定义需要的方法，例如： 123456789101112131415161718public class WebAppInterface &#123; Context mContext; /** * Instantiate the interface and set the context */ WebAppInterface(Context c) &#123; mContext = c; &#125; /** * Show a toast from the web page */ @JavascriptInterface public void showToastContent(String content) &#123; &#125;&#125; 注意，在方法定义前加上@JavascriptInterface注解。 生成第一步中定义的类的实例并添加给webview。 1webView.addJavascriptInterface(new WebAppInterface(getActivity()), \"TestObject\"); 这里的”TestObject”是随便起的名字，你可以改成其他的。这个名字主要是让webview的js调用的。 在js中通过”TestObject”对象调用客户端方法 1TestObject.showToastContent(\"haha\") 备上一段官网关于这个内容的代码： 1234567class JsObject &#123; @JavascriptInterface public String toString() &#123; return \"injectedObject\"; &#125; &#125; webView.addJavascriptInterface(new JsObject(), \"injectedObject\"); webView.loadData(\"\", \"text/html\", null); webView.loadUrl(\"javascript:alert(injectedObject.toString())\");","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"java.lang.OutOfMemoryError： unable to create new native thread","date":"2017-04-30T06:15:00.000Z","path":"2017/04/30/java-lang-OutOfMemoryError：-unable-to-create-new-native-thread/","text":"最新项目有版本更新，在打渠道包的时候老是刚打了一两个包的时候，就会抛出一个异常，导致打包失败：1java.lang.OutOfMemoryError： unable to create new native thread 由字面意思也可以知道是内存溢出了，在网上查了一下，说是创建了太多的线程。但是同样环境下，我们另外一个项目用相同的方式打包就没有出现这个问题，而且另外一个项目比出现问题的项目还要复杂一些，stackoverflow有人遇到了同样的问题： http://stackoverflow.com/questions/39599959/android-studio-2-2-gradle-build-fails-with-java-lang-outofmemoryerror-unable-t 他是把gradle插件版本回退解决的，猜想可能与gradle打包有关，对比了一下两个项目，发现编译版本不同，出现问题的项目编译版本较低，于是我把它从： 1buildToolsVersion '21.1.2' 升级成： 1buildToolsVersion '24.0.1' 问题解决。 具体什么原因还是没搞清，可能是旧的编译工具开启线程的极限过小，所以项目中以后还是用较新的吧。","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"Gradle 和Gradle Plugin区别","date":"2017-04-26T05:24:11.000Z","path":"2017/04/26/Gradle-和Gradle-Plugin区别/","text":"Gradle是一个构建工具，它是一个独立的项目。什么是构建工具呢？我的理解是：通过人为配置，它可以以自动化的形式执行一整套流程，例如在Android Studio用Gradle编译，打包等。 Gradle Plugin:谷歌在Android Studio中以Gradle作为构建系统，为了让开发者更好的使用，因此专门开发了一个插件来支持Gradle。 通常，在项目根目录下的build.gradle文件中设置Gradle Plugin版本： 1234567buildscript &#123; 。。。 dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.1' &#125; 。。。&#125; 在 根目录/gradle/wrapper/gradle-wrapper.properties中配置Gradle下载路径： 1distributionUrl=https\\://services.gradle.org/distributions/gradle-3.3-all.zip Gradle与Android Studio中的Gradle插件之间有对应关系： 相关官方介绍： Android Plugin for Gradle Release Notes Android Plugin各版本主要更新功能 Gradle版本列表 ​","tags":[{"name":"Gradle","slug":"Gradle","permalink":"//litten.me/tags/Gradle/"}]},{"title":"Butter Knife使用","date":"2017-04-14T13:23:26.000Z","path":"2017/04/14/Butter-Knife使用/","text":"Butter Knife用法总结一 导入1234dependencies &#123; compile 'com.jakewharton:butterknife:8.5.1' annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'&#125; 目前最新版为8.5.1 二 用法 单个控件绑定 123456789101112class ExampleActivity extends Activity &#123; @BindView(R.id.title) TextView title;//@BindView注解加控件id标注要查找的控件 @BindView(R.id.subtitle) TextView subtitle; @BindView(R.id.footer) TextView footer; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.simple_activity); ButterKnife.bind(this);//在当前activity自动绑定 // TODO Use fields... &#125;&#125; 资源绑定 1234567class ExampleActivity extends Activity &#123; @BindString(R.string.title) String title;//@BindString注解加资源id标注要查找的资源 @BindDrawable(R.drawable.graphic) Drawable graphic; @BindColor(R.color.red) int red; // int or ColorStateList field @BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field // ...&#125; 根据自定义的根布局来自动绑定布局里的控件 1234567891011public class FancyFragment extends Fragment &#123; @BindView(R.id.button1) Button button1; @BindView(R.id.button2) Button button2; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fancy_fragment, container, false); ButterKnife.bind(this, view);//自动绑定Activity根部局控件的时候直接传this即可 // TODO Use fields... return view; &#125;&#125; 在adapter里绑定控件 1234567891011121314151617181920212223242526public class MyAdapter extends BaseAdapter &#123; @Override public View getView(int position, View view, ViewGroup parent) &#123; ViewHolder holder; if (view != null) &#123; holder = (ViewHolder) view.getTag(); &#125; else &#123; view = inflater.inflate(R.layout.whatever, parent, false);//item布局 holder = new ViewHolder(view);//传给ViewHolder view.setTag(holder); &#125; holder.name.setText(\"John Doe\"); // etc... return view; &#125; static class ViewHolder &#123; @BindView(R.id.title) TextView name; @BindView(R.id.job_title) TextView jobTitle; public ViewHolder(View view) &#123; ButterKnife.bind(this, view);//其实就是根据我们自己提供的根布局来绑定控件 &#125; &#125;&#125; 控件集合绑定 12@BindViews(&#123; R.id.first_name, R.id.middle_name, R.id.last_name &#125;)List&lt;EditText&gt; nameViews; 同时操作多个控件 12ButterKnife.apply(nameViews, DISABLE);ButterKnife.apply(nameViews, ENABLED, false); DISABLE,ENABLED是ButterKnife提供的一种数据类型ButterKnife.Action，它是一个接口，需要我们根据需求实现其中的apply()方法，这里： 12345678910static final ButterKnife.Action&lt;View&gt; DISABLE = new ButterKnife.Action&lt;View&gt;() &#123; @Override public void apply(View view, int index) &#123; view.setEnabled(false); &#125;&#125;;static final ButterKnife.Setter&lt;View, Boolean&gt; ENABLED = new ButterKnife.Setter&lt;View, Boolean&gt;() &#123; @Override public void set(View view, Boolean value, int index) &#123; view.setEnabled(value); &#125;&#125;; 注意：ButterKnife.apply具有多个重载方法，例如还可以设置属性等： 1ButterKnife.apply(nameViews, View.ALPHA, 0.0f); 单个控件事件绑定 1234@OnClick(R.id.submit)//注解控件public void test(View view) &#123;//点击控件后触发的方法，参数可选 // TODO submit data to server...&#125; 多个控件事件绑定 12345678910111213141516@OnClick(&#123; R.id.door1, R.id.door2, R.id.door3 &#125;)public void test(View view) &#123; switch(view.getId())&#123; case R.id.door1: //todo something break; case R.id.door2: //todo something break; case R.id.door3: //todo something break; default: break; &#125;&#125; 绑定重置 与Activity相比，Fragment的视图具有不同的生命周期，在onCreateView中绑定视图的时候，Butter Knife会返回一个Unbinder类型的对象，我们可以在合适的生命周期回调方法中调用它unbind()方法来解除绑定。 1234567891011121314151617public class FancyFragment extends Fragment &#123; @BindView(R.id.button1) Button button1; @BindView(R.id.button2) Button button2; private Unbinder unbinder; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fancy_fragment, container, false); unbinder = ButterKnife.bind(this, view);//返回unbinder对象 // TODO Use fields... return view; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); unbinder.unbind();//解除绑定 &#125;&#125; 可选绑定（OPTIONAL BINDINGS） 通常，控件绑定与事件绑定我们都需要，但是如果没有找不到目标view的话会报错，为了避免这种情况，可以用@Nullable和@Optional这两个注解，如果找不到目标view存在，就自动绑定，不存在，也不会出错。 12345@Nullable @BindView(R.id.might_not_be_there) TextView mightNotBeThere;@Optional @OnClick(R.id.maybe_missing) void onMaybeMissingClicked() &#123; // TODO ...&#125; ButterKnife.findById() Butter Knife提供了一个findById()的方法，它主要用来简化控件类型转化： 1234View view = LayoutInflater.from(context).inflate(R.layout.thing, null);TextView firstName = ButterKnife.findById(view, R.id.first_name);TextView lastName = ButterKnife.findById(view, R.id.last_name);ImageView photo = ButterKnife.findById(view, R.id.photo); findById()有两个参数，第一个是目标view，有三种类型：View,Activity,Dialog，第二个参数是要查找的控件id。它主要是通过返回泛型来自动执行类型转换。 参考： []: http://jakewharton.github.io/butterknife/ []: https://github.com/JakeWharton/butterknife","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"让你的app有声音","date":"2017-04-13T07:19:54.000Z","path":"2017/04/13/让你的app有声音/","text":"之前写过一篇文章，当时的需求是播放英文，最后使用的是Androi自带的TextToSpeech类来实现（http://blog.csdn.net/weixin_38251977/article/details/69944088），虽然播放英文效果还行，但是对中文的支持不是很好。最近新项目中又遇到一个语音的需求，这次是中英文都有，各种对比之后，选择了百度语音离在线融合SDK,播放效果非常好，关键是免费。趁着有空，记录下集成步骤，抽成一个demo，下次有需要的时候可以直接套用。 一 前提步骤 首先，需要在百度语音官网注册一个账号，然后创建应用，创建一个应用的大致步骤如下图： 注册完应用后，根据我们给的包名，会生成对应的appid，apikey和secretkey，这几个参数在我们代码中会使用到。 二 代码集成 拷贝资源文件在上边儿注册应用的时候，我们已经把SDK下载下来了，在里边儿我们找到需要的jar包，so文件以及语音模型拷贝到我们的项目中，各资源文件对应目录如下：因为我的项目中只有armeabi架构，所以只拷贝了对应的资源，这个需要根据实际情况添加。 配置build文件将jar包等拷贝到项目中后，还需要配置工程目录下的build.gradle文件以添加依赖。首先，在android闭包中添加：android { sourceSets{ main{ jniLibs.srcDirs=[&apos;libs&apos;] } } } 这样Android Studio就能识别我们放在libs文件夹下的so文件了，不然的话运行的时候会报找不到so文件的错误。然后，在dependencies闭包中添加：compile files(&apos;libs/com.baidu.tts_2.3.0.jar&apos;) 到这里我们可以同步一下项目了，然后就可以在代码中使用jar包提供的方法了。 添加权限在清单文件中声明所需的权限：&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt; demo关于具体的使用方法，这里抽成了一个demo，代码我已经测试过了，运行没有问题（demo里只支持armeabi框架，你可以将官方sdk的所有架构对应的so文件都拷贝进去），代码址：https://github.com/SolveBugs/BaiduTTSDemo","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"事件分发主要过程","date":"2017-01-17T05:26:19.000Z","path":"2017/01/17/事件分发主要过程/","text":"Touch事件分发中只有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、onTouchEvent两个相关事件。其中ViewGroup又继承于View。 ViewGroup和View组成了一个树状结构，根节点为Activity内部包含的一个ViwGroup。 触摸事件由Action_Down、Action_Move、Aciton_UP组成，其中一次完整的触摸事件中，Down和Up都只有一个，Move有若干个，可以为0个。 当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。 当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。 当ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况下，触发Acitivity的onTouchEvent方法。 onInterceptTouchEvent有两个作用：1.拦截Down事件的分发。2.中止Up和Move事件向目标View传递，使得目标View所在的ViewGroup捕获Up和Move事件。","tags":[{"name":"知识点总结","slug":"知识点总结","permalink":"//litten.me/tags/知识点总结/"}]}]