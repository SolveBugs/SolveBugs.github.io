[{"title":"Butter Knife使用","date":"2017-04-14T13:23:26.000Z","path":"2017/04/14/Butter-Knife使用/","text":"Butter Knife用法总结一 导入1234dependencies &#123; compile 'com.jakewharton:butterknife:8.5.1' annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'&#125; 目前最新版为8.5.1 二 用法 单个控件绑定 123456789101112class ExampleActivity extends Activity &#123; @BindView(R.id.title) TextView title;//@BindView注解加控件id标注要查找的控件 @BindView(R.id.subtitle) TextView subtitle; @BindView(R.id.footer) TextView footer; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.simple_activity); ButterKnife.bind(this);//在当前activity自动绑定 // TODO Use fields... &#125;&#125; 资源绑定 1234567class ExampleActivity extends Activity &#123; @BindString(R.string.title) String title;//@BindString注解加资源id标注要查找的资源 @BindDrawable(R.drawable.graphic) Drawable graphic; @BindColor(R.color.red) int red; // int or ColorStateList field @BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field // ...&#125; 根据自定义的根布局来自动绑定布局里的控件 1234567891011public class FancyFragment extends Fragment &#123; @BindView(R.id.button1) Button button1; @BindView(R.id.button2) Button button2; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fancy_fragment, container, false); ButterKnife.bind(this, view);//自动绑定Activity根部局控件的时候直接传this即可 // TODO Use fields... return view; &#125;&#125; 在adapter里绑定控件 1234567891011121314151617181920212223242526public class MyAdapter extends BaseAdapter &#123; @Override public View getView(int position, View view, ViewGroup parent) &#123; ViewHolder holder; if (view != null) &#123; holder = (ViewHolder) view.getTag(); &#125; else &#123; view = inflater.inflate(R.layout.whatever, parent, false);//item布局 holder = new ViewHolder(view);//传给ViewHolder view.setTag(holder); &#125; holder.name.setText(\"John Doe\"); // etc... return view; &#125; static class ViewHolder &#123; @BindView(R.id.title) TextView name; @BindView(R.id.job_title) TextView jobTitle; public ViewHolder(View view) &#123; ButterKnife.bind(this, view);//其实就是根据我们自己提供的根布局来绑定控件 &#125; &#125;&#125; 控件集合绑定 12@BindViews(&#123; R.id.first_name, R.id.middle_name, R.id.last_name &#125;)List&lt;EditText&gt; nameViews; 同时操作多个控件 12ButterKnife.apply(nameViews, DISABLE);ButterKnife.apply(nameViews, ENABLED, false); DISABLE,ENABLED是ButterKnife提供的一种数据类型ButterKnife.Action，它是一个接口，需要我们根据需求实现其中的apply()方法，这里： 12345678910static final ButterKnife.Action&lt;View&gt; DISABLE = new ButterKnife.Action&lt;View&gt;() &#123; @Override public void apply(View view, int index) &#123; view.setEnabled(false); &#125;&#125;;static final ButterKnife.Setter&lt;View, Boolean&gt; ENABLED = new ButterKnife.Setter&lt;View, Boolean&gt;() &#123; @Override public void set(View view, Boolean value, int index) &#123; view.setEnabled(value); &#125;&#125;; 注意：ButterKnife.apply具有多个重载方法，例如还可以设置属性等： 1ButterKnife.apply(nameViews, View.ALPHA, 0.0f); 单个控件事件绑定 1234@OnClick(R.id.submit)//注解控件public void test(View view) &#123;//点击控件后触发的方法，参数可选 // TODO submit data to server...&#125; 多个控件事件绑定 12345678910111213141516@OnClick(&#123; R.id.door1, R.id.door2, R.id.door3 &#125;)public void test(View view) &#123; switch(view.getId())&#123; case R.id.door1: //todo something break; case R.id.door2: //todo something break; case R.id.door3: //todo something break; default: break; &#125;&#125; 绑定重置 与Activity相比，Fragment的视图具有不同的生命周期，在onCreateView中绑定视图的时候，Butter Knife会返回一个Unbinder类型的对象，我们可以在合适的生命周期回调方法中调用它unbind()方法来解除绑定。 1234567891011121314151617public class FancyFragment extends Fragment &#123; @BindView(R.id.button1) Button button1; @BindView(R.id.button2) Button button2; private Unbinder unbinder; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fancy_fragment, container, false); unbinder = ButterKnife.bind(this, view);//返回unbinder对象 // TODO Use fields... return view; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); unbinder.unbind();//解除绑定 &#125;&#125; 可选绑定（OPTIONAL BINDINGS） 通常，控件绑定与事件绑定我们都需要，但是如果没有找不到目标view的话会报错，为了避免这种情况，可以用@Nullable和@Optional这两个注解，如果找不到目标view存在，就自动绑定，不存在，也不会出错。 12345@Nullable @BindView(R.id.might_not_be_there) TextView mightNotBeThere;@Optional @OnClick(R.id.maybe_missing) void onMaybeMissingClicked() &#123; // TODO ...&#125; ButterKnife.findById() Butter Knife提供了一个findById()的方法，它主要用来简化控件类型转化： 1234View view = LayoutInflater.from(context).inflate(R.layout.thing, null);TextView firstName = ButterKnife.findById(view, R.id.first_name);TextView lastName = ButterKnife.findById(view, R.id.last_name);ImageView photo = ButterKnife.findById(view, R.id.photo); findById()有两个参数，第一个是目标view，有三种类型：View,Activity,Dialog，第二个参数是要查找的控件id。它主要是通过返回泛型来自动执行类型转换。 参考： []: http://jakewharton.github.io/butterknife/ []: https://github.com/JakeWharton/butterknife","tags":[]},{"title":"让你的app有声音","date":"2017-04-13T07:19:54.000Z","path":"2017/04/13/让你的app有声音/","text":"之前写过一篇文章，当时的需求是播放英文，最后使用的是Androi自带的TextToSpeech类来实现（http://blog.csdn.net/weixin_38251977/article/details/69944088），虽然播放英文效果还行，但是对中文的支持不是很好。最近新项目中又遇到一个语音的需求，这次是中英文都有，各种对比之后，选择了百度语音离在线融合SDK,播放效果非常好，关键是免费。趁着有空，记录下集成步骤，抽成一个demo，下次有需要的时候可以直接套用。 一 前提步骤 首先，需要在百度语音官网注册一个账号，然后创建应用，创建一个应用的大致步骤如下图： 注册完应用后，根据我们给的包名，会生成对应的appid，apikey和secretkey，这几个参数在我们代码中会使用到。 二 代码集成 拷贝资源文件在上边儿注册应用的时候，我们已经把SDK下载下来了，在里边儿我们找到需要的jar包，so文件以及语音模型拷贝到我们的项目中，各资源文件对应目录如下：因为我的项目中只有armeabi架构，所以只拷贝了对应的资源，这个需要根据实际情况添加。 配置build文件将jar包等拷贝到项目中后，还需要配置工程目录下的build.gradle文件以添加依赖。首先，在android闭包中添加：android { sourceSets{ main{ jniLibs.srcDirs=[&apos;libs&apos;] } } } 这样Android Studio就能识别我们放在libs文件夹下的so文件了，不然的话运行的时候会报找不到so文件的错误。然后，在dependencies闭包中添加：compile files(&apos;libs/com.baidu.tts_2.3.0.jar&apos;) 到这里我们可以同步一下项目了，然后就可以在代码中使用jar包提供的方法了。 添加权限在清单文件中声明所需的权限：&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt; demo关于具体的使用方法，这里抽成了一个demo，代码我已经测试过了，运行没有问题（demo里只支持armeabi框架，你可以将官方sdk的所有架构对应的so文件都拷贝进去），代码址：https://github.com/SolveBugs/BaiduTTSDemo","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"事件分发主要过程","date":"2017-01-17T05:26:19.000Z","path":"2017/01/17/事件分发主要过程/","text":"Touch事件分发中只有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、onTouchEvent两个相关事件。其中ViewGroup又继承于View。 ViewGroup和View组成了一个树状结构，根节点为Activity内部包含的一个ViwGroup。 触摸事件由Action_Down、Action_Move、Aciton_UP组成，其中一次完整的触摸事件中，Down和Up都只有一个，Move有若干个，可以为0个。 当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。 当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。 当ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况下，触发Acitivity的onTouchEvent方法。 onInterceptTouchEvent有两个作用：1.拦截Down事件的分发。2.中止Up和Move事件向目标View传递，使得目标View所在的ViewGroup捕获Up和Move事件。","tags":[{"name":"知识点总结","slug":"知识点总结","permalink":"//litten.me/tags/知识点总结/"}]}]