[{"title":"让你的app有声音","date":"2017-04-13T06:58:46.000Z","path":"2017/04/13/让你的app有声音/","text":"之前写过一篇文章，当时的需求是播放英文，最后使用的是Androi自带的TextToSpeech类来实现（http://blog.csdn.net/weixin_38251977/article/details/69944088），虽然播放英文效果还行，但是对中文的支持不是很好。最近新项目中又遇到一个语音的需求，这次是中英文都有，各种对比之后，选择了百度语音离在线融合SDK,播放效果非常好，关键是免费。趁着有空，记录下集成步骤，抽成一个demo，下次有需要的时候可以直接套用。 一 前提步骤 首先，需要在百度语音官网注册一个账号，然后创建应用，创建一个应用的大致步骤如下图： 注册完应用后，根据我们给的包名，会生成对应的appid，apikey和secretkey，这几个参数在我们代码中会使用到。 二 代码集成 拷贝资源文件在上边儿注册应用的时候，我们已经把SDK下载下来了，在里边儿我们找到需要的jar包，so文件以及语音模型拷贝到我们的项目中，各资源文件对应目录如下： 因为我的项目中只有armeabi架构，所以只拷贝了对应的资源，这个需要根据实际情况添加。 配置build文件将jar包等拷贝到项目中后，还需要配置工程目录下的build.gradle文件以添加依赖。首先，在android闭包中添加：android { sourceSets{ main{ jniLibs.srcDirs=[&apos;libs&apos;] } } } 这样Android Studio就能识别我们放在libs文件夹下的so文件了，不然的话运行的时候会报找不到so文件的错误。然后，在dependencies闭包中添加：compile files(&apos;libs/com.baidu.tts_2.3.0.jar&apos;) 到这里我们可以同步一下项目了，然后就可以在代码中使用jar包提供的方法了。 添加权限在清单文件中声明所需的权限：&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt; demo关于具体的使用方法，这里抽成了一个demo，代码我已经测试过了，运行没有问题（demo里只支持armeabi框架，你可以将官方sdk的所有架构对应的so文件都拷贝进去），代码址：https://github.com/SolveBugs/BaiduTTSDemo。","tags":[]},{"title":"事件分发主要过程","date":"2017-01-17T05:26:19.000Z","path":"2017/01/17/事件分发主要过程/","text":"Touch事件分发中只有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、onTouchEvent两个相关事件。其中ViewGroup又继承于View。 ViewGroup和View组成了一个树状结构，根节点为Activity内部包含的一个ViwGroup。 触摸事件由Action_Down、Action_Move、Aciton_UP组成，其中一次完整的触摸事件中，Down和Up都只有一个，Move有若干个，可以为0个。 当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。 当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。 当ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况下，触发Acitivity的onTouchEvent方法。 onInterceptTouchEvent有两个作用：1.拦截Down事件的分发。2.中止Up和Move事件向目标View传递，使得目标View所在的ViewGroup捕获Up和Move事件。","tags":[{"name":"知识点总结","slug":"知识点总结","permalink":"//litten.me/tags/知识点总结/"}]}]