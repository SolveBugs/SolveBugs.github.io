[{"title":"MVVM项目实战之路-搭建一个登录界面 ","date":"2017-12-29T05:10:31.000Z","path":"2017/12/29/MVVM项目实战之路-搭建一个登录界面/","text":"最近有一个新任务，给公司内部开发一个App，需求初始很简单，刚好之前一直在看MVVM这种开发模式，所以决定用Data Binding Library以及ViewModel等实现这种模式，因为代码和之前写法确实有很大不同，所以决定将这个app实现过程中这种新的模式的一些具体业务场景的代码写法用博客记录下来，希望对其他人有用。 本文基于Android Studio3.0 一.MVVM 首先，当然要先简单了解下什么是MVVM开发模式，来看一张图： 可以看出，在MVVM中，我们的代码结构分为三层： View这里主要进行视图控件的一些初始设置，不应该有任何的数据逻辑操作 Model在这层中，会定义我们的实体类，以及所有的业务逻辑操作，比如通过数据库或者网络来操作数据等都应该在这里进行 ViewModel就像上图一样，ViewModel是连接View与Model的中间桥梁，ViewModel与Model直接交互，处理完业务逻辑后，通过DataBinding将数据变化反应到用户界面上。 MVVM的具体意义以及与MVC,MVP等的对比这里不再赘述。 二.实现一个登录界面 这里，我们先用这种模式实现一个登录界面，界面简单如下： 需求很简单：用户输入用户名，密码，点击登录按钮后调用接口进行检查，成功则跳转到下一个界面，失败则提示错误信息。 废话不多说，It`s time to show code! 启用DataBinding首先，要保证你的Gradle插件版本要大于 1.5.0-alpha1及以上（现在基本都比这个版本高了吧），然后在app下的build.gradle文件添加以下代码：dataBinding { enabled = true} 2.添加ViewModel and LiveData implementation &quot;android.arch.lifecycle:extensions:1.0.0&quot; annotationProcessor “android.arch.lifecycle:compiler:1.0.0” 3.登录页面activity_login.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;viewmodel&quot; type=&quot;com.example.zq.mvvmdemo.user.LoginViewModel&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center_horizontal&quot; android:orientation=&quot;vertical&quot;&gt; &lt;EditText android:layout_width=&quot;240dp&quot; android:layout_height=&quot;40dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;100dp&quot; android:hint=&quot;@string/login_name&quot; android:text=&quot;@={viewmodel.loginName}&quot; /&gt; &lt;EditText android:layout_width=&quot;240dp&quot; android:layout_height=&quot;40dp&quot; android:layout_below=&quot;@+id/name&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;30dp&quot; android:hint=&quot;@string/login_password&quot; android:text=&quot;@={viewmodel.loginPass}&quot; /&gt; &lt;Button android:id=&quot;@+id/submit&quot; android:layout_width=&quot;240dp&quot; android:layout_height=&quot;40dp&quot; android:layout_below=&quot;@+id/password&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;40dp&quot; android:text=&quot;@string/login&quot; android:textSize=&quot;16dp&quot; /&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 从这里开始，就会发现和我们之前的写法有很大的区别了，之前的xml文件根节点是LinearLayout或者RelativeLayout等布局，但是在使用DataBinding后，我们的xml文件可以概括成这样： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout &gt; &lt;data&gt; ....... &lt;/data&gt; &lt;LinearLayout&gt; ........ 自己的布局 ........ &lt;/LinearLayout&gt; &lt;/layout&gt; 最外层以layout标签包裹，里边用data标签表示我们要绑定的数据的名字以及类型，然后就是我们自己的布局。 之前我们已经知道，ViewModel是View与Model层交互的桥梁，所以具体用到的业务数据，比如这里用户名，密码等我这里全部放到了ViewModel中，然后将ViewModel与View进行绑定： &lt;data&gt; &lt;variable name=&quot;viewmodel&quot; type=&quot;com.example.zq.mvvmdemo.user.LoginViewModel&quot; /&gt; &lt;/data&gt; 4.LoginViewModel文件 public class LoginViewModel extends AndroidViewModel { private static final String TAG = &quot;LoginViewModel&quot;; private final SingleLiveEvent&lt;String&gt; mOpenUserList = new SingleLiveEvent&lt;&gt;(); private final SnackbarMessage mSnackbarText = new SnackbarMessage(); private final Context mContext; // To avoid leaks, this must be an Application Context. public final ObservableField&lt;String&gt; loginName = new ObservableField&lt;&gt;(); public final ObservableField&lt;String&gt; loginPass = new ObservableField&lt;&gt;(); public LoginViewModel(Application mContext) { super(mContext); this.mContext = mContext.getApplicationContext(); } public SingleLiveEvent&lt;String&gt; getmOpenUserList() { return mOpenUserList; } SnackbarMessage getSnackbarMessage() { return mSnackbarText; } private void login(String loginName, String loginPass) { if (TextUtils.isEmpty(loginName)) { mSnackbarText.setValue(mContext.getString(R.string.login_name_not_input)); return; } if (TextUtils.isEmpty(loginPass)) { mSnackbarText.setValue(mContext.getString(R.string.login_pass_not_input)); return; } mOpenUserList.setValue(&quot;123456&quot;); } public void login() { login(loginName.get(), loginPass.get()); } } 首先我们来看loginName和loginPass这两个变量，ObservableField为DataBinding中提供的一个类，它使我们的对象变得可观测，即修改界面上的值，对应的loginName和loginPass的值就会改变，反之亦然。 再看mOpenUserList与mSnackbarText，它们是LiveData类型的，LiveData是一个数据持有类，并且在给定的生命周期中其变化是可观测的，这里用来处理ViewModels与 UI views (activities and fragments)的一些交互。 login()方法由点击登录按钮后触发，这里注意，因为loginName和loginPass已经与我们的视图文件绑定在一起了，所以就不用在调用的时候从EditText获取文本内容再传进来了。 getmOpenUserList()与getSnackbarMessage()将mOpenUserList与mSnackbarText公布给 UI views (activities and fragments)，来处理一些交互，在这个例子里，主要是弹出提示以及跳转页面。 5.LoginActivity文件 public class LoginActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ViewModelFactory factory = ViewModelFactory.getInstance(getApplication()); final LoginViewModel loginViewModel = ViewModelProviders.of(this, factory).get(LoginViewModel.class); final ActivityLoginBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_login); binding.setViewmodel(loginViewModel); loginViewModel.getmOpenUserList().observe(this, new Observer&lt;String&gt;() { @Override public void onChanged(@Nullable String s) { Intent intent = new Intent(LoginActivity.this, UserListActivity.class); intent.putExtra(&quot;token&quot;, s); startActivity(intent); finish(); } }); loginViewModel.getSnackbarMessage().observe(this, new SnackbarMessage.SnackbarObserver() { @Override public void onNewMessage(String message) { SnackbarUtils.showSnackbar(binding.getRoot(), message); } }); findViewById(R.id.submit).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { loginViewModel.login(); } }); } } 这里就相当于View层，按照前面说的，这里应该只有一些界面的设置，不应该有任何的逻辑处理。ActivityLoginBinding是自动生成的，注意，在写完xml文件后要Build-Make Project一下，才会生成这个文件。 梳理一下逻辑： 点击登录按钮后，会调用LoginViewModel中的login()方法，进行参数的检查，如果参数不合法，为mSnackbarText设置对应的文案提示，因为我们在Activity已经监测了mSnackbarText的 变化，当它的值发生变化后，会通过回调通知回来，我们可以进行提示： SnackbarUtils.showSnackbar(binding.getRoot(), message); 当参数全部合法后，改变mOpenUserList，同样会触发回调，进而跳转到下一个界面： Intent intent = new Intent(LoginActivity.this, UserListActivity.class); intent.putExtra(&quot;token&quot;, s); startActivity(intent); finish(); 以上就是用这种新的开发模式来完成这个登录需求的一个记录，写法与之前确实有很大不同，其中的一些问题可能描述的也不是很清楚，欢迎大佬给出建议和指正错误，会慢慢改正。 demo代码地址：https://github.com/SolveBugs/MVVMDemo","tags":[]},{"title":"升级Android支持库版本遇到的两个问题","date":"2017-10-16T09:49:33.000Z","path":"2017/10/16/升级Android支持库版本遇到的两个问题/","text":"公司项目之前support Library 版本比较混乱，各moudle有好几个版本的v7包和v4包，而且版本还比较低，今天抽时间统一了下支持库以及buildToolsVersion等的版本，但是遇到了两个问题，记录一下。 ###1. 升级buildToolsVersion至26最新的buildToolsVersion已经到26了，照之前方式，直接在build文件中将buildToolsVersion后的引用版本改为26.0.2，然后同步，发现编不过去，提示：1[failed to find build tools revision 26.0.2] 查了一下，从sdk 26开始，需要在根目录build文件的repositories加上以下内容：123456repositories &#123; jcenter() maven &#123; url &quot;https://maven.google.com&quot; &#125; &#125; 再次编译，成功。 ###2. 在主题设置隐藏ActionBar无效最初我的appcompat-v7版本是20，所以activity继承的是ActionBarActivity，所以在style文件里是这样设置是有用的的：12&lt;item name=&quot;android:windowActionBar&quot; tools:targetApi=&quot;honeycomb&quot;&gt;false&lt;/item&gt;&lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; 升级到26.1.0后，ActionBarActivity被AppCompatActivity替代，这时候用android:windowActionBar这种方式设置就不行了，改为以下方式12&lt;item name=&quot;windowActionBar&quot; tools:targetApi=&quot;honeycomb&quot;&gt;false&lt;/item&gt;&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; 即去掉“android：”,至于这两种写法的区别： 若添加在属性名称前添加 andoird: 时即指定属性为 android 包下。而项目的 Base Style AppTheme 继承自 Theme.AppCompat,位于 appcompat-v7 library, 而不是 android 包下。所以错误地使用 android:windowActionBar 和 android:windowNoTitle，应该使用 windowActionBar 和 windowNoTitle","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"String类设计成不可变的好处","date":"2017-10-11T05:36:36.000Z","path":"2017/10/11/String类设计成不可变的好处/","text":"String是所有语言中最常用的一个类。我们知道在Java中，String是不可变的、final的。Java在运行时也保存了一个字符串池(String pool)，这使得String成为了一个特别的类。 String类不可变性的好处:…1.只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现(译者注：Stringinterning是指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串。，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量 的值也会一起改变。 2.如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连 接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符 串指向的对象的值，造成安全漏洞。 3.因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。 4.类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。 5.因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。","tags":[{"name":"知识点总结","slug":"知识点总结","permalink":"//litten.me/tags/知识点总结/"}]},{"title":"从源码梳理Retrofit网络请求过程","date":"2017-09-25T08:31:35.000Z","path":"2017/09/25/从源码梳理Retrofit网络请求过程/","text":"通过定义一个接口，在方法上加入相关注解，Retrofit框架就可以把它解析成对应的网络请求，使用非常方便，记录下从源码角度看这个过程是怎么实现的。 一 Retrofit的引入在Android Studio中引入Retrofit非常方便，目标最新版本是2.3，在app-build文件-dependencies节点下加入以下依赖即可：123456compile &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;compile &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos;compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;compile &apos;io.reactivex.rxjava2:rxjava:2.1.0&apos; 这里引入最后的两个依赖是为了与rx结合使用，可以先不加。 二 Retrofit是如何通过接口来生成网络请求的 首先，我们定一个接口，同时声明一个方法：1234public interface ApiService &#123; @GET(&quot;users/&#123;user&#125;/repos&quot;) Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);&#125; 这里我们要请求github某个用户下的所有仓库。 调用很简单：12345678910111213141516171819ApiService apiService = retrofit.create(ApiService.class);Call&lt;List&lt;Repo&gt;&gt; solveBus = apiService.listRepos(&quot;SolveBugs&quot;);solveBus.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() &#123; @Override public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) &#123; List&lt;Repo&gt; repoList = response.body(); StringBuilder sb = new StringBuilder(); for (Repo repo : repoList) &#123; sb.append(repo.getName()); sb.append(&quot;\\n&quot;); &#125; textView.setText(sb.toString()); &#125; @Override public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) &#123; &#125; &#125;); 来看retrofit. create()方法 这个方法返回的是一个动态代理对象，当我们用这个对象调用listRepos方法的时候实际上会走到这里的invoke方法，在这个方法里，首先根据接口定义的方法，生成一个ServiceMethod对象，看一下ServiceMethod这个类的注释：1Adapts an invocation of an interface method into an HTTP call. 所以这个类就是一个关于http请求信息的封装。那么是怎么封装的呢？主要逻辑在loadServiceMethod方法里。12345678910111213ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123; ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result; &#125; 逻辑很清晰，首先从缓存里取，如果没有的传入method(即我们声明的接口中的方法对象)，通过build方法生成一个，然后放入缓存。在build方法中，遍历method的所有注解，来取出其中的信息，比如请求方法以及地址等：123for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation);&#125; 拿到封装好的ServiceMethod对象后，构造一个OkHttpCall对象，以便与进行真正的网络请求（Retrofit基于OkHttp实现网络请求）。1OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); 回到最开始调用的地方： 这里真正调用的是okHttpCall对象的enqueue方法,这里进行的就是具体的网络请求操作了。 代码逻辑其实还是比较清晰的，主要是用到了很多设计模式，所以看起来可能有些费劲，里边儿的细节还要细细研究。（逃，继续看源码去）","tags":[{"name":"知识点总结","slug":"知识点总结","permalink":"//litten.me/tags/知识点总结/"}]},{"title":"使用AppOpsManager类检查通知权限是否开启","date":"2017-07-25T06:56:24.000Z","path":"2017/07/25/使用AppOpsManager类检查通知权限是否开启/","text":"最近产品统计用户通知权限打开率，用到了系统提供的AppOpsManager类，使用很简单，但是有一点要注意：这个类在4.4之前是没有的，如果不加判断会造成4.4以下设备崩溃。 123456789101112131415161718192021222324252627282930313233public static boolean isNotificationEnabled(Context context) &#123; int currentApiVersion = Build.VERSION.SDK_INT; if (currentApiVersion &lt; Build.VERSION_CODES.KITKAT) &#123; //api4.4一下无法知道通知是否开启，默认返回false return false; &#125; AppOpsManager mAppOps = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); ApplicationInfo appInfo = context.getApplicationInfo(); String pkg = context.getApplicationContext().getPackageName(); int uid = appInfo.uid; Class appOpsClass = null; /* Context.APP_OPS_MANAGER */ try &#123; appOpsClass = Class.forName(AppOpsManager.class.getName()); Method checkOpNoThrowMethod = appOpsClass.getMethod(CHECK_OP_NO_THROW, Integer.TYPE, Integer.TYPE, String.class); Field opPostNotificationValue = appOpsClass.getDeclaredField(OP_POST_NOTIFICATION); int value = (int) opPostNotificationValue.get(Integer.class); return ((int) checkOpNoThrowMethod.invoke(mAppOps, value, uid, pkg) == AppOpsManager.MODE_ALLOWED); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return false; &#125;","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"ExpandableStickyListHeadersListView遇到的一个问题","date":"2017-05-26T02:54:18.000Z","path":"2017/05/26/StickyListHeadersListView遇到的一个问题/","text":"最近一直忙着版本更新，记录一下中间遇到的一些问题。 ExpandableStickyListHeadersListView这个开源库主要是实现列表分组的，常见的需求用它还是不错的，项目中也有用到这个控件，一直没有什么问题，但是，这期需求测试在用华为nexus p6做测试的时候，发现了一个奇怪的问题： 在列表快速滑动的时候，点击返回键离开当前界面，app会崩溃，崩溃日志如下：1Attempt to invoke virtual method 'void android.view.View.dispatchWindowFocusChanged() on a null object (大致意思是用一个空的对象调用了dispatchWindowFocusChanged（）方法) 起初以为是app逻辑问题，这样的话应该是必现的，但是试了华为，oppo，魅族以及小米后，都没有出现这个问题。于是goole，但是也没有搜到，怀疑是系统某个地方出现异常了…虽然没有搜到解决办法，但是也得解啊（不然没法儿上线…） 中间也试了不少办法，但是都没用，最后想到，既然是View对象调用方法的时候出现异常导致程序崩溃，那我是不是可以复写这个方法，捕捉异常来保证不崩溃？于是重写方法： 12345678@Override public void dispatchWindowFocusChanged(boolean hasFocus) &#123; try &#123; super.dispatchWindowFocusChanged(hasFocus); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 再在华为nexux p6上测试，问题解决。","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"webview调用android代码","date":"2017-05-05T10:13:52.000Z","path":"2017/05/05/webview调用android代码/","text":"在开发的时候经常会用到webview，必然会涉及到webview与客户端的交互，比如在网页上进行某个操作后，需要在app上显示一个提示，提示内容由网页提供，这时候就需要js来调用客户端的java代码了。 webview提供了一个方法addJavascriptInterface()来满足这种需求。具体步骤： 客户端定义一个类，并定义需要的方法，例如： 123456789101112131415161718public class WebAppInterface &#123; Context mContext; /** * Instantiate the interface and set the context */ WebAppInterface(Context c) &#123; mContext = c; &#125; /** * Show a toast from the web page */ @JavascriptInterface public void showToastContent(String content) &#123; &#125;&#125; 注意，在方法定义前加上@JavascriptInterface注解。 生成第一步中定义的类的实例并添加给webview。 1webView.addJavascriptInterface(new WebAppInterface(getActivity()), \"TestObject\"); 这里的”TestObject”是随便起的名字，你可以改成其他的。这个名字主要是让webview的js调用的。 在js中通过”TestObject”对象调用客户端方法 1TestObject.showToastContent(\"haha\") 备上一段官网关于这个内容的代码： 1234567class JsObject &#123; @JavascriptInterface public String toString() &#123; return \"injectedObject\"; &#125; &#125; webView.addJavascriptInterface(new JsObject(), \"injectedObject\"); webView.loadData(\"\", \"text/html\", null); webView.loadUrl(\"javascript:alert(injectedObject.toString())\");","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"java.lang.OutOfMemoryError： unable to create new native thread","date":"2017-04-30T06:15:00.000Z","path":"2017/04/30/java-lang-OutOfMemoryError：-unable-to-create-new-native-thread/","text":"最新项目有版本更新，在打渠道包的时候老是刚打了一两个包的时候，就会抛出一个异常，导致打包失败：1java.lang.OutOfMemoryError： unable to create new native thread 由字面意思也可以知道是内存溢出了，在网上查了一下，说是创建了太多的线程。但是同样环境下，我们另外一个项目用相同的方式打包就没有出现这个问题，而且另外一个项目比出现问题的项目还要复杂一些，stackoverflow有人遇到了同样的问题：http://stackoverflow.com/questions/39599959/android-studio-2-2-gradle-build-fails-with-java-lang-outofmemoryerror-unable-t 他是把gradle插件版本回退解决的，猜想可能与gradle打包有关，对比了一下两个项目，发现编译版本不同，出现问题的项目编译版本较低，于是我把它从： 1buildToolsVersion '21.1.2' 升级成： 1buildToolsVersion &apos;24.0.1&apos; 问题解决。 具体什么原因还是没搞清，可能是旧的编译工具开启线程的极限过小，所以项目中以后还是用较新的吧。","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"Gradle 和Gradle Plugin区别","date":"2017-04-26T05:24:11.000Z","path":"2017/04/26/Gradle-和Gradle-Plugin区别/","text":"Gradle是一个构建工具，它是一个独立的项目。什么是构建工具呢？我的理解是：通过人为配置，它可以以自动化的形式执行一整套流程，例如在Android Studio用Gradle编译，打包等。 Gradle Plugin:谷歌在Android Studio中以Gradle作为构建系统，为了让开发者更好的使用，因此专门开发了一个插件来支持Gradle。 通常，在项目根目录下的build.gradle文件中设置Gradle Plugin版本： 1234567buildscript &#123; 。。。 dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.1' &#125; 。。。&#125; 在 根目录/gradle/wrapper/gradle-wrapper.properties中配置Gradle下载路径： 1distributionUrl=https\\://services.gradle.org/distributions/gradle-3.3-all.zip Gradle与Android Studio中的Gradle插件之间有对应关系： 相关官方介绍： Android Plugin for Gradle Release Notes Android Plugin各版本主要更新功能 Gradle版本列表 ​","tags":[{"name":"Gradle","slug":"Gradle","permalink":"//litten.me/tags/Gradle/"}]},{"title":"Butter Knife使用","date":"2017-04-14T13:23:26.000Z","path":"2017/04/14/Butter-Knife使用/","text":"Butter Knife用法总结一 导入1234dependencies &#123; compile 'com.jakewharton:butterknife:8.5.1' annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'&#125; 目前最新版为8.5.1 二 用法 单个控件绑定 123456789101112class ExampleActivity extends Activity &#123; @BindView(R.id.title) TextView title;//@BindView注解加控件id标注要查找的控件 @BindView(R.id.subtitle) TextView subtitle; @BindView(R.id.footer) TextView footer; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.simple_activity); ButterKnife.bind(this);//在当前activity自动绑定 // TODO Use fields... &#125;&#125; 资源绑定 1234567class ExampleActivity extends Activity &#123; @BindString(R.string.title) String title;//@BindString注解加资源id标注要查找的资源 @BindDrawable(R.drawable.graphic) Drawable graphic; @BindColor(R.color.red) int red; // int or ColorStateList field @BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field // ...&#125; 根据自定义的根布局来自动绑定布局里的控件 1234567891011public class FancyFragment extends Fragment &#123; @BindView(R.id.button1) Button button1; @BindView(R.id.button2) Button button2; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fancy_fragment, container, false); ButterKnife.bind(this, view);//自动绑定Activity根部局控件的时候直接传this即可 // TODO Use fields... return view; &#125;&#125; 在adapter里绑定控件 1234567891011121314151617181920212223242526public class MyAdapter extends BaseAdapter &#123; @Override public View getView(int position, View view, ViewGroup parent) &#123; ViewHolder holder; if (view != null) &#123; holder = (ViewHolder) view.getTag(); &#125; else &#123; view = inflater.inflate(R.layout.whatever, parent, false);//item布局 holder = new ViewHolder(view);//传给ViewHolder view.setTag(holder); &#125; holder.name.setText(\"John Doe\"); // etc... return view; &#125; static class ViewHolder &#123; @BindView(R.id.title) TextView name; @BindView(R.id.job_title) TextView jobTitle; public ViewHolder(View view) &#123; ButterKnife.bind(this, view);//其实就是根据我们自己提供的根布局来绑定控件 &#125; &#125;&#125; 控件集合绑定 12@BindViews(&#123; R.id.first_name, R.id.middle_name, R.id.last_name &#125;)List&lt;EditText&gt; nameViews; 同时操作多个控件 12ButterKnife.apply(nameViews, DISABLE);ButterKnife.apply(nameViews, ENABLED, false); DISABLE,ENABLED是ButterKnife提供的一种数据类型ButterKnife.Action，它是一个接口，需要我们根据需求实现其中的apply()方法，这里： 12345678910static final ButterKnife.Action&lt;View&gt; DISABLE = new ButterKnife.Action&lt;View&gt;() &#123; @Override public void apply(View view, int index) &#123; view.setEnabled(false); &#125;&#125;;static final ButterKnife.Setter&lt;View, Boolean&gt; ENABLED = new ButterKnife.Setter&lt;View, Boolean&gt;() &#123; @Override public void set(View view, Boolean value, int index) &#123; view.setEnabled(value); &#125;&#125;; 注意：ButterKnife.apply具有多个重载方法，例如还可以设置属性等： 1ButterKnife.apply(nameViews, View.ALPHA, 0.0f); 单个控件事件绑定 1234@OnClick(R.id.submit)//注解控件public void test(View view) &#123;//点击控件后触发的方法，参数可选 // TODO submit data to server...&#125; 多个控件事件绑定 12345678910111213141516@OnClick(&#123; R.id.door1, R.id.door2, R.id.door3 &#125;)public void test(View view) &#123; switch(view.getId())&#123; case R.id.door1: //todo something break; case R.id.door2: //todo something break; case R.id.door3: //todo something break; default: break; &#125;&#125; 绑定重置 与Activity相比，Fragment的视图具有不同的生命周期，在onCreateView中绑定视图的时候，Butter Knife会返回一个Unbinder类型的对象，我们可以在合适的生命周期回调方法中调用它unbind()方法来解除绑定。 1234567891011121314151617public class FancyFragment extends Fragment &#123; @BindView(R.id.button1) Button button1; @BindView(R.id.button2) Button button2; private Unbinder unbinder; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fancy_fragment, container, false); unbinder = ButterKnife.bind(this, view);//返回unbinder对象 // TODO Use fields... return view; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); unbinder.unbind();//解除绑定 &#125;&#125; 可选绑定（OPTIONAL BINDINGS） 通常，控件绑定与事件绑定我们都需要，但是如果没有找不到目标view的话会报错，为了避免这种情况，可以用@Nullable和@Optional这两个注解，如果找不到目标view存在，就自动绑定，不存在，也不会出错。 12345@Nullable @BindView(R.id.might_not_be_there) TextView mightNotBeThere;@Optional @OnClick(R.id.maybe_missing) void onMaybeMissingClicked() &#123; // TODO ...&#125; ButterKnife.findById() Butter Knife提供了一个findById()的方法，它主要用来简化控件类型转化： 1234View view = LayoutInflater.from(context).inflate(R.layout.thing, null);TextView firstName = ButterKnife.findById(view, R.id.first_name);TextView lastName = ButterKnife.findById(view, R.id.last_name);ImageView photo = ButterKnife.findById(view, R.id.photo); findById()有两个参数，第一个是目标view，有三种类型：View,Activity,Dialog，第二个参数是要查找的控件id。它主要是通过返回泛型来自动执行类型转换。 参考： []: http://jakewharton.github.io/butterknife/ []: https://github.com/JakeWharton/butterknife","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"让你的app有声音","date":"2017-04-13T07:19:54.000Z","path":"2017/04/13/让你的app有声音/","text":"之前写过一篇文章，当时的需求是播放英文，最后使用的是Androi自带的TextToSpeech类来实现（http://blog.csdn.net/weixin_38251977/article/details/69944088 ） ，虽然播放英文效果还行，但是对中文的支持不是很好。最近新项目中又遇到一个语音的需求，这次是中英文都有，各种对比之后，选择了百度语音离在线融合SDK,播放效果非常好，关键是免费。趁着有空，记录下集成步骤，抽成一个demo，下次有需要的时候可以直接套用。 一 前提步骤 首先，需要在百度语音官网注册一个账号，然后创建应用，创建一个应用的大致步骤如下图： 注册完应用后，根据我们给的包名，会生成对应的appid，apikey和secretkey，这几个参数在我们代码中会使用到。 二 代码集成 拷贝资源文件在上边儿注册应用的时候，我们已经把SDK下载下来了，在里边儿我们找到需要的jar包，so文件以及语音模型拷贝到我们的项目中，各资源文件对应目录如下：因为我的项目中只有armeabi架构，所以只拷贝了对应的资源，这个需要根据实际情况添加。 配置build文件将jar包等拷贝到项目中后，还需要配置工程目录下的build.gradle文件以添加依赖。首先，在android闭包中添加：android { sourceSets{ main{ jniLibs.srcDirs=[&apos;libs&apos;] } } } 这样Android Studio就能识别我们放在libs文件夹下的so文件了，不然的话运行的时候会报找不到so文件的错误。然后，在dependencies闭包中添加：compile files(&apos;libs/com.baidu.tts_2.3.0.jar&apos;) 到这里我们可以同步一下项目了，然后就可以在代码中使用jar包提供的方法了。 添加权限在清单文件中声明所需的权限：&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt; demo关于具体的使用方法，这里抽成了一个demo，代码我已经测试过了，运行没有问题（demo里只支持armeabi框架，你可以将官方sdk的所有架构对应的so文件都拷贝进去），代码址：https://github.com/SolveBugs/BaiduTTSDemo","tags":[{"name":"开发经验","slug":"开发经验","permalink":"//litten.me/tags/开发经验/"}]},{"title":"事件分发主要过程","date":"2017-01-17T05:26:19.000Z","path":"2017/01/17/事件分发主要过程/","text":"Touch事件分发中只有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、onTouchEvent两个相关事件。其中ViewGroup又继承于View。 ViewGroup和View组成了一个树状结构，根节点为Activity内部包含的一个ViwGroup。 触摸事件由Action_Down、Action_Move、Aciton_UP组成，其中一次完整的触摸事件中，Down和Up都只有一个，Move有若干个，可以为0个。 当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。 当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。 当ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况下，触发Acitivity的onTouchEvent方法。 onInterceptTouchEvent有两个作用：1.拦截Down事件的分发。2.中止Up和Move事件向目标View传递，使得目标View所在的ViewGroup捕获Up和Move事件。","tags":[{"name":"知识点总结","slug":"知识点总结","permalink":"//litten.me/tags/知识点总结/"}]}]